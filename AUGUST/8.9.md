# 8.9

## 스택

### 특성

- 자료를 쌓아 올린 형태의 자료구조
- 선형 구조(자료 간의 관계가 1대 1의 관계)
- 스택에 자료 삽입, 자료 꺼낼 수 있다
- **후입선출(LIFO,마지막에 삽입한 자료를 가장 먼저 꺼냄)**



### 구현

- 자료구조 : 자료를 선형으로 저장할 저장소
  - 배열 사용
  - 저장소 자체 == 스택
  - 스택에서 마지막 삽입된 원소의 위치 : top / stack pointer(sp)
- 연산
  - 삽입 : 자료 저장(push)
  - 삭제 : 자료 역순으로 꺼냄(pop)
  - isEmpty : 공백인지 아닌지 확인
  - peek : top에 있는 item(원소) 반환



- 삽입/삭제 과정

  - 빈 스택에 원소 A,B,C를 차례로 삽입 후 한번 삭제하는 연산과정

  ```python
  # stack push
  def push(item):
      s.append()
      
  def push(item, size):
      global top
      top += 1
      if top == size:
          print('overflow!')
      else:
          stack[top] = item
  
  size = 10
  stack = [0] * size
  top = -1
  
  push(10, size)
  top += 1  # push(20)
  stack[top] = 20
  
  # stack pop
  def pop():
      if len(s) == 0:
          # underflow
          return
      else:
          return s.pop()
      
  def pop():
      global top
      if top == -1:
          print('underflow')
          return 0
      else:
          top -= 1
          return stack[top+1]
  
  print(pop())
  
  if top > -1:   # pop()
      top -= 1
      print(stack[top+1])
  ```



### 고려사항

- 1차원 배열을 사용하여 구현할 경우 구현이 용이
- 스택의 크기 변경 어려움
- 저장소를 동적으로 할당하여 스택 구현(동적 연결리스트 이용) : 메모리 효율적 사용



### 괄호검사

- 괄호 종류 : 대괄호([ ]), 중괄호({ }), 소괄호(( ))
- 조건 
  - 왼쪽 괄호의 개수 == 오른쪽 괄호 개수
  - 같은 괄호에서 왼쪽 괄호는 오른쪽보다 먼저
  - 괄호 사이에는 포함 관계만 존재



### function call

- 함수 호출과 복귀에 따른 수행 순서 관리
- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조 -> 후입선출 구조의 스택을 이용하여 수행순서 관리
- 순서
  - 함수 호출이 발생하면 호출한 함수 수해에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장 후 시스템 스택에 삽입
  - 함수의 실행이 끝나면 시스텐 스택의 top 원소(스택 프레임)를 삭제(pop) 하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
  - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 됨 



## 재귀호출

### 재귀호출

- 자기 자신을 호출하여 순환 수행되는 것
- 프로그램의 크기 축소 및 간단 작성 가능

```python
# factorial
n! = n x (n-1)!
	(n-1)! = (n-1) x (n-2)
    
# 파보나치 수를 구하는 재귀함수
def fibo(n):
    if n < 2:
        return n
    else:
        return fibo(n-1) + fibo(n-2)
```



## Memoization

### Memoization

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
- 동적 계획법의 핵심이 되는 기술

```python
# memo를 위한 배열을 할당하고, 모두 0으로 초기화 
# memo[0]을 0으로 memo[1]는 1로 초기화

def fibo1(n):
    global memo
    if n >= 2 and memo[n] == 0:
        memo[n] = (fibo1(n-1) + fibo1(n-2))
    return memo[n]

memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
```



## DP

## DFS

