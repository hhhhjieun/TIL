# 연습 문제(Tree)
'''
V
부모-자식
13
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
'''

def preorder(n):
    if n:  # 존재하는 정점이면
        print(n)  # visit(n)
        preorder(ch1[n])  # 왼쪽 subtree 로 이동
        preorder(ch2[n])  # 오른쪽 subtree 로 이동


V = int(input())  # 정점 수 = 마지막 정점 번호
E = V - 1  # tree 의 간선 수 = 정점 수 - 1
arr = list(map(int, input().split()))

# 부모를 인덱스로 자식 저장
# 자식을 인덱스로 부모 저장

ch1 = [0] * (V+1)
ch2 = [0] * (V+1)
par = [0] * (V+1)
for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    if ch1[p] == 0:  # 자식1이 아직 없으면
        ch1[p] = c
    else:
        ch2[p] = c

    par[c] = p  # 자식을 인덱스로 부모 저장

# 실제 루트 찾기
root = 1
while par[root] != 0:
    root += 1

preorder(root)

'''
<Tree 순회 방법>

1. pre_order(전위)
- 처음 지나갈때 방문
- 자식 노드를 좌, 우 순서로 방문

2. in_order(중위)
- 왼쪽에서 돌아올 때 방문
- 왼쪽 자식 방문
- 부모 노드 방문 
- 오른쪽 자식 방문

3. post_order(후위)
- 오른쪽에서 돌아오면서 방문
- 자식노드를 좌, 우 순서로 방문
- 부모노드 방문

<사용>
- 전위 순회:
> 루트 노드를 가장 먼저 방문하기 때문에, 트리의 구조를 파악하기 쉬움
(트리의 레이아웃 파악 -> 복사, 트리의 균형 파악)

- 중위 순회:
> 이진트리에 많이 활용
> - 이진트리는 왼쪽 자식노드의 크기가 부모보다 작고, 오른쪽 자식 노드의 크기가 부모보다 크다
> - 이진트리의 값들을 정렬된 순서로 받아올 수 있다
> 빠른 검색 : 정렬되어있기 때문에, 빠르게 검색할 수 있다
> 정렬되지 않은 데이터를 가지고 이진트리를 구성하면, 정렬된 효과를 얻을 수 있다
 
- 후위 순회:
> 리프 노드에서 부터 탐색을 시작하는 특징
> 삭제와 삽입
 - 노드의 삭제와 삽입을 할 경우, 자식 노드부터 처리할 수 있다 

<트리 vs 그래프>
- 그래프
> 정의 : 노드와 간선으로 구성되는 자료구조
> 방향성 : 방향 그래프 O, 무방향 그래프 O
> 루트 노드 : X
> 부모 / 자식 관계 : X

- 트리
> 정의 : 그래프의 한 종류, 방향성이 있는 비순환 그래프
> 방향성 : 방향 그래프 O, 무방향 그래프 X
> 루트 노드 : O
> 부모 / 자식 관계 : O
'''